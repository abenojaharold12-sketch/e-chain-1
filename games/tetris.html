<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üü¶ Tetris Mobile</title>
<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: linear-gradient(#111, #222);
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px;
  }

  h1 {
    margin: 10px 0;
    text-align: center;
    font-size: 28px;
    color: #00e6ff;
    text-shadow: 1px 1px 4px black;
  }

  canvas {
    border: 3px solid #00e6ff;
    border-radius: 10px;
    background: #111;
    width: 100%;
    max-width: 240px;
    height: auto;
  }

  .scoreboard {
    margin-top: 10px;
    font-size: 18px;
    display: flex;
    justify-content: space-between;
    width: 100%;
    max-width: 240px;
  }

  .controls-container {
    display: flex;
    justify-content: space-between;
    width: 100%;
    max-width: 240px;
    margin-top: 15px;
    align-items: center;
  }

  .dpad {
    display: grid;
    grid-template-columns: 50px 50px 50px;
    grid-template-rows: 50px 50px 50px;
    gap: 5px;
    justify-content: center;
    align-items: center;
  }

  .dpad button {
    padding: 0;
    font-size: 22px;
    border: none;
    border-radius: 8px;
    background: #00e6ff;
    color: #111;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    touch-action: manipulation;
    transition: transform 0.1s, background 0.2s;
  }

  .dpad button:active {
    background: #00b0cc;
    transform: scale(0.95);
  }

  .dpad .left { grid-column: 1; grid-row: 2; }
  .dpad .down { grid-column: 2; grid-row: 2; }
  .dpad .right { grid-column: 3; grid-row: 2; }

  .rotate-btn {
    width: 60px;
    height: 60px;
    font-size: 28px;
    border-radius: 50%;
    border: none;
    background: #00e6ff;
    color: #111;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.1s, background 0.2s;
    display: flex;
    justify-content: center;
    align-items: center;
    touch-action: manipulation;
  }

  .rotate-btn:active {
    background: #00b0cc;
    transform: scale(0.95);
  }

  .next-piece {
    margin-left: 20px;
    text-align: center;
  }

  .next-piece h3 { margin-bottom: 5px; }

  @media (max-width:480px){
    .dpad button, .rotate-btn { width: 70px; height: 70px; font-size: 30px; }
    h1 { font-size: 24px; }
  }
</style>
</head>
<body>

<h1>üü¶ Tetris</h1>

<div style="display:flex;align-items:flex-start;">
  <canvas id="tetris" width="240" height="400"></canvas>

  <div class="next-piece">
    <h3>Next:</h3>
    <canvas id="next" width="80" height="80" style="background:#111;border:2px solid #00e6ff;border-radius:8px;"></canvas>
  </div>
</div>

<div class="scoreboard">
  <div>Score: <span id="score">0</span></div>
  <div>High Score: <span id="highScore">0</span></div>
</div>

<div class="controls-container">
  <div class="dpad">
    <button class="left" onclick="playerMove(-1)">‚¨ÖÔ∏è</button>
    <button class="down" onclick="playerDrop()">‚¨áÔ∏è</button>
    <button class="right" onclick="playerMove(1)">‚û°Ô∏è</button>
  </div>
  <button class="rotate-btn" id="rotateBtn">üîÉ</button>
</div>

<script>
const canvas = document.getElementById("tetris");
const ctx = canvas.getContext("2d");
ctx.scale(20,20);

const nextCanvas = document.getElementById("next");
const nextCtx = nextCanvas.getContext("2d");
nextCtx.scale(20,20);

function createMatrix(w,h){
  const matrix=[];
  while(h--) matrix.push(new Array(w).fill(0));
  return matrix;
}

function createPiece(type){
  switch(type){
    case 'T': return [[0,1,0],[1,1,1]];
    case 'O': return [[2,2],[2,2]];
    case 'L': return [[0,0,3],[3,3,3]];
    case 'J': return [[4,0,0],[4,4,4]];
    case 'I': return [[5,5,5,5]];
    case 'S': return [[0,6,6],[6,6,0]];
    case 'Z': return [[7,7,0],[0,7,7]];
  }
}

function drawMatrix(matrix,offset,context=ctx){
  const w = matrix[0].length;
  const h = matrix.length;
  const xOffset = (context===nextCtx) ? Math.floor((nextCanvas.width/20 - w)/2) : offset.x;
  const yOffset = (context===nextCtx) ? Math.floor((nextCanvas.height/20 - h)/2) : offset.y;
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0){
        context.fillStyle=colors[value];
        context.fillRect(x + xOffset, y + yOffset, 1, 1);
      }
    });
  });
}

function draw(){
  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(arena,{x:0,y:0});
  drawMatrix(player.matrix,player.pos);
  drawNext();
}

function collide(arena,player){
  const [m,o]=[player.matrix,player.pos];
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]!==0 && (arena[y+o.y] && arena[y+o.y][x+o.x])!==0){
        return true;
      }
    }
  }
  return false;
}

function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0) arena[y+player.pos.y][x+player.pos.x]=value;
    });
  });
}

function rotate(matrix){
  const N = matrix.length;
  const rotated = matrix.map((row,y) =>
    row.map((val,x) => matrix[N-1-x][y])
  );
  return rotated;
}

function playerRotate(){
  const rotated = rotate(player.matrix);
  if(!collide(arena,{pos:player.pos,matrix:rotated})){
    player.matrix = rotated;
  }
}

function playerMove(dir){
  player.pos.x+=dir;
  if(collide(arena,player)) player.pos.x-=dir;
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena,player)){
    player.pos.y--;
    merge(arena,player);
    resetPlayer();
    arenaSweep();
  }
  dropCounter=0;
}

function arenaSweep(){
  let rowCount=1;
  outer: for(let y=arena.length-1;y>=0;y--){
    for(let x=0;x<arena[y].length;x++){
      if(arena[y][x]===0) continue outer;
    }
    const row=arena.splice(y,1)[0].fill(0);
    arena.unshift(row);
    player.score+=rowCount*10;
    rowCount*=2;
  }
  updateScore();
}

function resetPlayer(){
  player.matrix = nextPiece;
  player.pos.y=0;
  player.pos.x=(arena[0].length/2|0)-(player.matrix[0].length/2|0);
  nextPiece = createPiece('TJLOSZI'[Math.floor(Math.random()*7)]);
  if(collide(arena,player)){
    arena.forEach(row=>row.fill(0));
    player.score=0;
    updateScore();
  }
}

function drawNext(){
  nextCtx.fillStyle="#111";
  nextCtx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
  drawMatrix(nextPiece,{x:0,y:0},nextCtx);
}

function updateScore(){
  document.getElementById("score").textContent=player.score;
  if(player.score>highScore) highScore=player.score;
  document.getElementById("highScore").textContent=highScore;
}

let dropCounter=0;
let dropInterval=1000;
let lastTime=0;
let highScore=0;
let nextPiece = createPiece('TJLOSZI'[Math.floor(Math.random()*7)]);

const arena = createMatrix(12,20);
const player = {pos:{x:0,y:0},matrix:createPiece('T'),score:0};
const colors=[null,'#FF0D72','#0DC2FF','#0DFF72','#F538FF','#FF8E0D','#FFE138','#3877FF'];

document.addEventListener("keydown",e=>{
  if(e.key==="ArrowLeft") playerMove(-1);
  else if(e.key==="ArrowRight") playerMove(1);
  else if(e.key==="ArrowDown") playerDrop();
  else if(e.key==="ArrowUp") playerRotate();
});

// Make rotate button mobile-friendly
const rotateBtn = document.getElementById("rotateBtn");
rotateBtn.addEventListener("touchstart", (e) => { e.preventDefault(); playerRotate(); draw(); });
rotateBtn.addEventListener("click", ()=>{ playerRotate(); draw(); });

function update(time=0){
  const deltaTime=time-lastTime;
  lastTime=time;
  dropCounter+=deltaTime;
  if(dropCounter>dropInterval) playerDrop();
  draw();
  requestAnimationFrame(update);
}

update();
updateScore();
</script>
</body>
</html>
