<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetris Mobile</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: black;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-family: Arial, sans-serif;
  color: white;
}

canvas {
  border: 1px solid white;
  width: 100%;
  max-width: 320px;
  height: auto;
}

.controls {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 10px;
  margin: 10px 0;
}

.controls button {
  padding: 10px 15px;
  font-size: 18px;
  border: none;
  border-radius: 6px;
  background: #ff6f61;
  color: white;
  cursor: pointer;
}

@media (max-width:480px){
  .controls button {
    padding: 15px 20px;
    font-size: 20px;
  }
}
</style>
</head>
<body>

<h2>üü¶ Tetris</h2>
<canvas width="320" height="640" id="game"></canvas>
<div class="controls">
  <button onclick="moveLeft()">‚¨ÖÔ∏è</button>
  <button onclick="moveDown()">‚¨áÔ∏è</button>
  <button onclick="moveRight()">‚û°Ô∏è</button>
  <button onclick="rotateTetromino()">üîÑ</button>
</div>

<script>
// --- Helpers ---
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function generateSequence() {
  const sequence = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
  while(sequence.length) {
    const rand = getRandomInt(0, sequence.length - 1);
    const name = sequence.splice(rand, 1)[0];
    tetrominoSequence.push(name);
  }
}

function getNextTetromino() {
  if(tetrominoSequence.length === 0) generateSequence();
  const name = tetrominoSequence.pop();
  const matrix = tetrominos[name];
  const col = playfield[0].length/2 - Math.ceil(matrix[0].length/2);
  const row = name==='I'?-1:-2;
  return {name, matrix, row, col};
}

function rotate(matrix) {
  const N = matrix.length-1;
  return matrix.map((row,i)=>row.map((val,j)=>matrix[N-j][i]));
}

function isValidMove(matrix, row, col) {
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<matrix[y].length;x++){
      if(matrix[y][x] && (
        col+x<0 || col+x>=playfield[0].length || row+y>=playfield.length || playfield[row+y][col+x]
      )) return false;
    }
  }
  return true;
}

function placeTetromino() {
  for(let y=0;y<tetromino.matrix.length;y++){
    for(let x=0;x<tetromino.matrix[y].length;x++){
      if(tetromino.matrix[y][x]){
        if(tetromino.row+y<0) return gameOverScreen();
        playfield[tetromino.row+y][tetromino.col+x]=tetromino.name;
      }
    }
  }
  for(let row=playfield.length-1; row>=0;) {
    if(playfield[row].every(cell=>!!cell)) {
      for(let r=row; r>=0;r--){
        for(let c=0;c<playfield[r].length;c++){
          playfield[r][c]=playfield[r-1]?.[c]||0;
        }
      }
    } else row--;
  }
  tetromino=getNextTetromino();
}

function gameOverScreen(){
  cancelAnimationFrame(rAF);
  gameOver=true;
  context.fillStyle='black';
  context.globalAlpha=0.75;
  context.fillRect(0,canvas.height/2-30,canvas.width,60);
  context.globalAlpha=1;
  context.fillStyle='white';
  context.font='36px monospace';
  context.textAlign='center';
  context.textBaseline='middle';
  context.fillText('GAME OVER',canvas.width/2,canvas.height/2);
}

// --- Game Setup ---
const canvas = document.getElementById('game');
const context = canvas.getContext('2d');
const grid=32;
const tetrominoSequence=[];
const playfield=[];
for(let row=-2;row<20;row++){
  playfield[row]=[];
  for(let col=0;col<10;col++) playfield[row][col]=0;
}

const tetrominos = {
  'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  'J': [[1,0,0],[1,1,1],[0,0,0]],
  'L': [[0,0,1],[1,1,1],[0,0,0]],
  'O': [[1,1],[1,1]],
  'S': [[0,1,1],[1,1,0],[0,0,0]],
  'Z': [[1,1,0],[0,1,1],[0,0,0]],
  'T': [[0,1,0],[1,1,1],[0,0,0]]
};

const colors={
  'I':'cyan','O':'yellow','T':'purple','S':'green',
  'Z':'red','J':'blue','L':'orange'
};

let count=0;
let tetromino=getNextTetromino();
let rAF=null;
let gameOver=false;

// --- Controls ---
function moveLeft(){ if(!gameOver && isValidMove(tetromino.matrix,tetromino.row,tetromino.col-1)) tetromino.col--;}
function moveRight(){ if(!gameOver && isValidMove(tetromino.matrix,tetromino.row,tetromino.col+1)) tetromino.col++;}
function moveDown(){ if(!gameOver) {
  if(isValidMove(tetromino.matrix,tetromino.row+1,tetromino.col)){tetromino.row++;} else {placeTetromino();}
}}
function rotateTetromino(){ if(!gameOver){
  const matrix=rotate(tetromino.matrix);
  if(isValidMove(matrix,tetromino.row,tetromino.col)) tetromino.matrix=matrix;
}}

// --- Keyboard ---
document.addEventListener('keydown',e=>{
  if(gameOver) return;
  if(e.key==='ArrowLeft') moveLeft();
  if(e.key==='ArrowRight') moveRight();
  if(e.key==='ArrowDown') moveDown();
  if(e.key==='ArrowUp') rotateTetromino();
});

// --- Game Loop ---
function loop(){
  rAF=requestAnimationFrame(loop);
  context.clearRect(0,0,canvas.width,canvas.height);

  if(tetromino){
    if(++count>35){ tetromino.row++; count=0; if(!isValidMove(tetromino.matrix,tetromino.row,tetromino.col)){tetromino.row--; placeTetromino();} }
    context.fillStyle=colors[tetromino.name];
    for(let row=0;row<tetromino.matrix.length;row++){
      for(let col=0;col<tetromino.matrix[row].length;col++){
        if(tetromino.matrix[row][col]){
          context.fillRect((tetromino.col+col)*grid,(tetromino.row+row)*grid,grid-1,grid-1);
        }
      }
    }
  }

  // draw playfield
  for(let row=0;row<20;row++){
    for(let col=0;col<10;col++){
      if(playfield[row][col]){
        context.fillStyle=colors[playfield[row][col]];
        context.fillRect(col*grid,row*grid,grid-1,grid-1);
      }
    }
  }
}

rAF=requestAnimationFrame(loop);
</script>
</body>
</html>
