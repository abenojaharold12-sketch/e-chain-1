<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mobile Tetris with Next Piece</title>
<style>
  html, body {height:100%; margin:0; font-family: Arial; user-select:none; -webkit-user-select:none;}
  body {background:black; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:10px;}
  canvas {border:1px solid white; touch-action:none;}
  #next-piece {margin-bottom:10px;}
  #score {color:white; font-size:20px; margin-bottom:10px; text-align:center;}
  .controls {margin-top:10px; display:flex; justify-content:center; gap:15px;}
  .controls button {width:60px; height:60px; font-size:24px; border:none; border-radius:8px; background:#00e6ff; color:#111; font-weight:bold; touch-action:none;}
  .controls button:active {background:#00b0cc; transform:scale(0.95);}
  @media(max-width:480px){.controls button{width:70px;height:70px;font-size:28px;}}
</style>
</head>
<body>

<div id="score">Score: 0</div>
<canvas id="next-piece" width="128" height="128"></canvas>
<canvas width="320" height="640" id="game"></canvas>

<div class="controls">
  <button id="left">‚¨ÖÔ∏è</button>
  <button id="down">‚¨áÔ∏è</button>
  <button id="right">‚û°Ô∏è</button>
  <button id="rotate">üîÉ</button>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const grid = 32;

const nextCanvas = document.getElementById('next-piece');
const nextCtx = nextCanvas.getContext('2d');

let score = 0;

function getRandomInt(min,max){return Math.floor(Math.random()*(max-min+1))+min;}
let tetrominoSequence = [];

function generateSequence(){const seq=['I','J','L','O','S','T','Z'];while(seq.length){tetrominoSequence.push(seq.splice(getRandomInt(0,seq.length-1),1)[0]);}}
function getNextTetromino(){if(tetrominoSequence.length===0) generateSequence(); const name = tetrominoSequence.pop(); const matrix = tetrominos[name]; const col = Math.floor(playfield[0].length/2 - Math.ceil(matrix[0].length/2)); const row = (name==='I')?-1:-2; return {name,matrix,row,col};}
function rotate(matrix){const N=matrix.length-1;return matrix.map((r,i)=>r.map((v,j)=>matrix[N-j][i]));}
function isValidMove(matrix,row,col){for(let r=0;r<matrix.length;r++){for(let c=0;c<matrix[r].length;c++){if(matrix[r][c] && (col+c<0 || col+c>=playfield[0].length || row+r>=playfield.length || playfield[row+r][col+c])) return false;}}return true;}
function placeTetromino(){for(let r=0;r<tetromino.matrix.length;r++){for(let c=0;c<tetromino.matrix[r].length;c++){if(tetromino.matrix[r][c]){if(tetromino.row+r<0) return showGameOver(); playfield[tetromino.row+r][tetromino.col+c]=tetromino.name;}}}
// clear full rows
for(let r=playfield.length-1;r>=0;){if(playfield[r].every(cell=>!!cell)){for(let rr=r;rr>=0;rr--) for(let cc=0;cc<10;cc++) playfield[rr][cc]=playfield[rr-1]?playfield[rr-1][cc]:0; score+=10; updateScore();}else r--;}
tetromino = nextTetromino; nextTetromino = getNextTetromino(); drawNextPiece();}

function showGameOver(){cancelAnimationFrame(rAF); gameOver=true; ctx.fillStyle='black'; ctx.globalAlpha=0.75; ctx.fillRect(0,canvas.height/2-30,canvas.width,60); ctx.globalAlpha=1; ctx.fillStyle='white'; ctx.font='36px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('GAME OVER!',canvas.width/2,canvas.height/2);}

const playfield=[]; for(let r=-2;r<20;r++){playfield[r]=[];for(let c=0;c<10;c++) playfield[r][c]=0;}
const tetrominos={'I':[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],'J':[[1,0,0],[1,1,1],[0,0,0]],'L':[[0,0,1],[1,1,1],[0,0,0]],'O':[[1,1],[1,1]],'S':[[0,1,1],[1,1,0],[0,0,0]],'Z':[[1,1,0],[0,1,1],[0,0,0]],'T':[[0,1,0],[1,1,1],[0,0,0]]};
const colors={'I':'cyan','O':'yellow','T':'purple','S':'green','Z':'red','J':'blue','L':'orange'};

let count=0, tetromino=getNextTetromino(), nextTetromino=getNextTetromino(), rAF=null, gameOver=false;

// draw main playfield
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let r=0;r<20;r++){for(let c=0;c<10;c++){if(playfield[r][c]){ctx.fillStyle=colors[playfield[r][c]];ctx.fillRect(c*grid,r*grid,grid-1,grid-1);}}}
  for(let r=0;r<tetromino.matrix.length;r++){for(let c=0;c<tetromino.matrix[r].length;c++){if(tetromino.matrix[r][c]){ctx.fillStyle=colors[tetromino.name];ctx.fillRect((tetromino.col+c)*grid,(tetromino.row+r)*grid,grid-1,grid-1);}}}
}

function drawNextPiece(){
  nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  const m = nextTetromino.matrix;
  const size = m.length;
  const offsetX = (nextCanvas.width/2 - size*grid/2);
  const offsetY = (nextCanvas.height/2 - size*grid/2);
  for(let r=0;r<m.length;r++){for(let c=0;c<m[r].length;c++){if(m[r][c]){nextCtx.fillStyle=colors[nextTetromino.name]; nextCtx.fillRect(offsetX + c*grid, offsetY + r*grid, grid-1, grid-1);}}}
}

// game loop
function loop(){rAF=requestAnimationFrame(loop);if(gameOver) return; count++; if(count>35){tetromino.row++; if(!isValidMove(tetromino.matrix,tetromino.row,tetromino.col)){tetromino.row--; placeTetromino();} count=0;} draw();}
rAF=requestAnimationFrame(loop);

function move(dir){const col=tetromino.col+dir;if(isValidMove(tetromino.matrix,tetromino.row,col)) tetromino.col=col;}
function drop(){const row=tetromino.row+1;if(!isValidMove(tetromino.matrix,row,tetromino.col)){tetromino.row=row-1; placeTetromino(); return;} tetromino.row=row;}
function rotateTet(){const matrix=rotate(tetromino.matrix); if(isValidMove(matrix,tetromino.row,tetromino.col)) tetromino.matrix=matrix;}

function updateScore(){document.getElementById('score').textContent='Score: '+score;}

// keyboard support
document.addEventListener('keydown',e=>{
  if(gameOver) return;
  if(e.key==='ArrowLeft') move(-1);
  else if(e.key==='ArrowRight') move(1);
  else if(e.key==='ArrowDown') drop();
  else if(e.key==='ArrowUp') rotateTet();
});

// mobile buttons
document.getElementById('left').addEventListener('touchstart',e=>{e.preventDefault(); move(-1); draw();});
document.getElementById('right').addEventListener('touchstart',e=>{e.preventDefault(); move(1); draw();});
document.getElementById('down').addEventListener('touchstart',e=>{e.preventDefault(); drop(); draw();});
document.getElementById('rotate').addEventListener('touchstart',e=>{e.preventDefault(); rotateTet(); draw();});
document.getElementById('rotate').addEventListener('click',()=>{rotateTet(); draw();});

// swipe gestures
let startX=0,startY=0;
document.addEventListener('touchstart',e=>{startX=e.touches[0].clientX; startY=e.touches[0].clientY;});
document.addEventListener('touchend',e=>{
  if(gameOver) return;
  const dx=e.changedTouches[0].clientX-startX;
  const dy=e.changedTouches[0].clientY-startY;
  if(Math.abs(dx)>Math.abs(dy)){dx>30?move(1):dx<-30?move(-1):null;}
  else{dy>30?drop():dy<-30?rotateTet():null;}
  draw();
});

// initialize next piece preview
drawNextPiece();
updateScore();

</script>
</body>
</html>
