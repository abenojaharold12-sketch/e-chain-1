<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Frogger Mobile</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: black;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-family: Arial, sans-serif;
  color: white;
}

canvas {
  border: 2px solid white;
  width: 100%;
  max-width: 624px;
  height: auto;
}

.controls {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 10px;
  margin: 10px 0;
}

.controls button {
  padding: 10px 15px;
  font-size: 18px;
  border: none;
  border-radius: 6px;
  background: #ff6f61;
  color: white;
  cursor: pointer;
}

@media (max-width:480px){
  .controls button {
    padding: 15px 20px;
    font-size: 20px;
  }
}
</style>
</head>
<body>

<h2>üê∏ Frogger</h2>
<canvas width="624" height="720" id="game"></canvas>

<div class="controls">
  <button onclick="moveFrog('up')">‚¨ÜÔ∏è</button>
  <button onclick="moveFrog('left')">‚¨ÖÔ∏è</button>
  <button onclick="moveFrog('down')">‚¨áÔ∏è</button>
  <button onclick="moveFrog('right')">‚û°Ô∏è</button>
</div>

<script>
const canvas = document.getElementById('game');
const context = canvas.getContext('2d');

const grid = 48;
const gridGap = 10;

function Sprite(props) {
  Object.assign(this, props);
}
Sprite.prototype.render = function(){
  context.fillStyle=this.color;
  if(this.shape==='rect'){
    context.fillRect(this.x, this.y + gridGap/2, this.size, grid-gridGap);
  } else {
    context.beginPath();
    context.arc(this.x + this.size/2, this.y + this.size/2, this.size/2 - gridGap/2, 0, Math.PI*2);
    context.fill();
  }
}

// Frog
const frogger = new Sprite({x:grid*6,y:grid*13,color:'greenyellow',size:grid,shape:'circle'});
const scoredFroggers = [];

// Obstacle patterns
const patterns = [
  null,
  {spacing:[2],color:'#c55843',size:grid*4,shape:'rect',speed:0.75},
  {spacing:[0,2,0,2,0,2,0,4],color:'#de0004',size:grid,shape:'circle',speed:-1},
  {spacing:[2],color:'#c55843',size:grid*7,shape:'rect',speed:1.5},
  {spacing:[3],color:'#c55843',size:grid*3,shape:'rect',speed:0.5},
  {spacing:[0,0,1],color:'#de0004',size:grid,shape:'circle',speed:-1},
  null,
  {spacing:[3,8],color:'#c2c4da',size:grid*2,shape:'rect',speed:-1},
  {spacing:[14],color:'#c2c4da',size:grid,shape:'rect',speed:0.75},
  {spacing:[3,3,7],color:'#de3cdd',size:grid,shape:'rect',speed:-0.75},
  {spacing:[3,3,7],color:'#0bcb00',size:grid,shape:'rect',speed:0.5},
  {spacing:[4],color:'#e5e401',size:grid,shape:'rect',speed:-0.5},
  null
];

const rows = [];
for(let i=0;i<patterns.length;i++){
  rows[i]=[];
  let x=0, index=0;
  const pattern=patterns[i];
  if(!pattern) continue;
  let totalWidth=pattern.spacing.reduce((a,b)=>a+b,0)*grid + pattern.spacing.length*pattern.size;
  let endX=0;
  while(endX<canvas.width) endX+=totalWidth;
  endX+=totalWidth;
  while(x<endX){
    rows[i].push(new Sprite({...pattern,x,y:grid*(i+1),index}));
    const spacing=pattern.spacing;
    x+=pattern.size + spacing[index]*grid;
    index=(index+1)%spacing.length;
  }
}

// --- Game functions ---
function loop(){
  requestAnimationFrame(loop);
  context.clearRect(0,0,canvas.width,canvas.height);

  // background zones
  context.fillStyle='#000047'; context.fillRect(0,grid,canvas.width,grid*6);
  context.fillStyle='#1ac300'; context.fillRect(0,grid,canvas.width,5);
  context.fillStyle='#8500da'; context.fillRect(0,7*grid,canvas.width,grid);
  context.fillRect(0,canvas.height-grid*2,canvas.width,grid);

  // obstacles
  for(let r=0;r<rows.length;r++){
    const row=rows[r];
    for(let i=0;i<row.length;i++){
      const s=row[i];
      s.x+=s.speed; s.render();

      if(s.speed<0 && s.x<s.size*-1){
        let rightMost=s;
        for(let j=0;j<row.length;j++){ if(row[j].x>rightMost.x) rightMost=row[j]; }
        const spacing=patterns[r].spacing;
        s.x=rightMost.x+s.size+spacing[rightMost.index]*grid;
        s.index=(rightMost.index+1)%spacing.length;
      }
      if(s.speed>0 && s.x>canvas.width){
        let leftMost=s;
        for(let j=0;j<row.length;j++){ if(row[j].x<leftMost.x) leftMost=row[j]; }
        const spacing=patterns[r].spacing;
        let index=leftMost.index-1; index=index>=0?index:spacing.length-1;
        s.x=leftMost.x - spacing[index]*grid - s.size;
        s.index=index;
      }
    }
  }

  // frog
  frogger.x+=frogger.speed||0;
  frogger.render();

  // scored frogs
  scoredFroggers.forEach(f=>f.render());

  // collision detection
  const frogRow=frogger.y/grid-1|0;
  let collision=false;
  for(let i=0;i<rows[frogRow].length;i++){
    const s=rows[frogRow][i];
    if(frogger.x<s.x+s.size-gridGap &&
       frogger.x+grid-gridGap>s.x &&
       frogger.y<s.y+grid &&
       frogger.y+grid>s.y){
      collision=true;
      if(frogRow>rows.length/2){ frogger.x=grid*6; frogger.y=grid*13;}
      else frogger.speed=s.speed;
    }
  }
  if(!collision){
    frogger.speed=0;
    const col=(frogger.x+grid/2)/grid|0;
    if(frogRow===0 && col%3===0 && !scoredFroggers.find(f=>f.x===col*grid)){
      scoredFroggers.push(new Sprite({...frogger,x:col*grid,y:frogger.y+5}));
    }
    if(frogRow<rows.length/2-1){ frogger.x=grid*6; frogger.y=grid*13;}
  }
}

function moveFrog(dir){
  if(dir==='up') frogger.y-=grid;
  else if(dir==='down') frogger.y+=grid;
  else if(dir==='left') frogger.x-=grid;
  else if(dir==='right') frogger.x+=grid;

  // clamp to canvas
  frogger.x=Math.min(Math.max(0,frogger.x),canvas.width-grid);
  frogger.y=Math.min(Math.max(grid,frogger.y),canvas.height-grid*2);
}

// keyboard controls
document.addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft') moveFrog('left');
  if(e.key==='ArrowRight') moveFrog('right');
  if(e.key==='ArrowUp') moveFrog('up');
  if(e.key==='ArrowDown') moveFrog('down');
});

loop();
</script>
</body>
</html>
